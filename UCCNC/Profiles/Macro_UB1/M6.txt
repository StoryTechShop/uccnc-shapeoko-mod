/**
 * Macro: M6 Tool Change
 * UCCNC v1.2115 or higher required, with Messages plugin enabled
 * 
 * Unload current tool to load new tool
 * Moves back to XY position after tool change
 * 
 * Unloading Current Tool:
 *  If tool has "Probe" or "NoStore" tag in tool type field, will prompt for manually unloading tool
 *  If current tool has no slot assigned, it is assigned next empty slot
 *  If no empty slots are available, will prompt for manually unloading tool
 * 
 * Loading New Tool:
 *  If new tool is not in a slot, will prompt for manually loading tool
 *  Newly loaded tool keeps assigned slot to be placed at on unload
 *  If unload was detected to be unsuccessful, additional attempts will be made before failing
 * 
 * Tool Detection:
 *  Checks that tool was successfully ejected for both auto and manual tool unloading
 *  Checks that tool was successfully clamped for both auto and manual tool loading
 *  Checks that tool is clamped if new tool is same as current tool
 *  Sensor states are debounced with a given amount of time to meet their expected state before failing
 * 
 * atcLEDToolClamp=false and atcLEDToolRelease=false
 *  drawbar overtraveling above clamp sensor (no tool) or
 *  not reaching full extension to release sensor (jam/low air pressure)
 *  depending on 'atcOutputToolRelease' state
 * 
 * atcLEDToolClamp=true and atcLEDToolRelease=false
 *  drawbar petal clamped tool, travel stopped at clamp sensor
 * 
 * atcLEDToolClamp=false and atcLEDToolRelease=true
 *  drawbar petal unclamped, travel bottoming out at release sensor
 * 
 * NOTE: Tool table slot data is saved in custom profile section due to limitations in UCCNC API when auto-assign is enabled
 * Custom screenset fields can be used to represent tool table with macro to load and save changes (see M21050 and M21051)
 */

// ### M6 CONFIG ###

// UCCNC has limitation in tool table API (http://forum.cncdrive.com/viewtopic.php?f=13&t=3537)
// if auto-assign is enabled, the UCCNC tool table can't be used to manage the tool slot number
// WARNING: DO NOT CHANGE AFTER A TOOL IS ASSIGNED A SLOT - STORED STATE OF TOOL SLOTS AND TOOL RACK WILL NOT MATCH
var profileAutoAssignToolSlot = true;
// we are resorting to using a custom section for tool slot in the profile to prevent losing data if auto assign is enabled
var profileToolTableSlotSection = profileAutoAssignToolSlot ? "M6ToolTable" : "Tooltablevalues";

// safe Z position for travel
double zSafe = 0.0D;

// Z position to release tool
double zToolRelease = -5.0250D;
// Z position to clamp tool
double zToolClamp = zToolRelease;

// distance above tool release/clamp position to feed and toggle air purge
double zRetract = 0.5D;
// feedrate when moving to or out of tool release/clamp position
int zRetractFeed = 20; 

// manual tool change position
var toolManualPosition = new Position(-9.0D, -18.0D); // position for manual tool changes - TODO change to a Park location instead?
// enable prompts to engage release and clamp
var toolManualATCPrompts = false;

// tool slot XY positions
var toolSlots = new Position[]{
    // Slot 0 does not exist
    new Position(double.NaN, double.NaN),
    // Slot 1
    new Position(-18.0066D, -0.1277D),
    // Slot 2
    new Position(-15.8446D, -0.1306D),
    // Slot 3
    new Position(-13.6887D, -0.1300D),
    // Slot 4
    new Position(-11.5288D, -0.1379D),
    // Slot 5
    new Position(-9.3756D, -0.1328D),
    // Slot 6
    new Position(-7.2092D, -0.1208D),
    // Slot 7
    new Position(-5.0576D, -0.1175D),
    // Slot 8
    new Position(-2.9006D, -0.1346D),
};

 // OUTPUT to engage drawbar release
var atcOutputToolRelease = new PortPin(3, 1);
// OUTPUT to engage drawbar clamp - optional, can be set to null
PortPin? atcOutputToolClamp = null; // new PortPin(3, 2);
 // OUTPUT to engage air purge
var atcOutputPurge = new PortPin(3, 3);

// INPUT to detect if a tool is clamped
var atcLEDToolClamp = 96; // InputPT3PN11
// INPUT to detect drawbar release
var atcLEDToolRelease = 97; // InputPT3PN12

// Interrupt from failure: 130=Cycle Stop or 512=RESET
var buttonInterrupt = 130;
// Cancel from user: 130=Cycle Stop or 512=RESET
var buttonCancel = 130;

// ### M6 MACRO ###

var toolCurrentNumber = exec.Getcurrenttool();
var toolNewNumber = exec.Getnewtool();

// If machine was not homed then it is unsafe to move in machine coordinates, stop here...
if(!exec.GetLED(56)||!exec.GetLED(57)||!exec.GetLED(58))
{
    exec.Callbutton(buttonInterrupt);
    Prompt("M6: Tool Change Failed", "Machine is not homed", "OK", true);
    return;
}

// Check if there is a tool in the spindle
if(toolCurrentNumber > 0 && !AssertClampPosition(atcLEDToolClamp, true, atcLEDToolRelease, false)){
    exec.Callbutton(buttonInterrupt);
    Prompt("M6: Tool Change Failed", "Tool not in spindle", "OK", true);
    return;
}

// if same tool, do nothing
if(toolCurrentNumber == toolNewNumber){
    return;
}

// store original XY position and modal to restore
var originalPosition = new Position(exec.GetXmachpos(), exec.GetYmachpos());
var originalModal = AS3.Getfield(877).Split('|');

if(!ExecuteGCode(
    // stop spindle
    "M5",
    // move to safe z
    "G90 G00 G53 Z" + zSafe
)){
    exec.AddStatusmessage("M6: tool change interrupted");
    return;
}

// read the tool slot #
var toolCurrentSlot = toolCurrentNumber > 0 ? int.Parse(exec.Readkey(profileToolTableSlotSection, "Slot"+toolCurrentNumber, "0")) : 0;
var toolNewSlot = toolNewNumber > 0 ? int.Parse(exec.Readkey(profileToolTableSlotSection, "Slot"+toolNewNumber, "0")) : 0;

// read the tool desc
var toolCurrentDesc = exec.Readkey("Tooltablevalues", "Description"+toolCurrentNumber, "");
var toolNewDesc = exec.Readkey("Tooltablevalues", "Description"+toolNewNumber, "");

// check that tool slot not out of range
if(toolCurrentSlot >= toolSlots.Length){
    exec.Callbutton(buttonInterrupt);
    Prompt("M6: Tool Change Failed", "T" + toolCurrentNumber + " slot #" + toolCurrentSlot + " out of range", "OK", true);
    return;
}
if(toolNewSlot >= toolSlots.Length){
    exec.Callbutton(buttonInterrupt);
    Prompt("M6: Tool Change Failed", "T" + toolNewNumber + " slot #" + toolNewSlot + " out of range", "OK", true);
    return;
}

// read and parse tool flags
var toolCurrentTypeFlags = exec.Readkey("Tooltablevalues", "Type"+toolCurrentNumber, "").Split(new char[]{' ', ',', ';'});
var toolCurrentStorable = !Array.Exists(toolCurrentTypeFlags, f => string.Equals(f, "Probe", StringComparison.InvariantCultureIgnoreCase) ||
                                                                    string.Equals(f, "NoStore", StringComparison.InvariantCultureIgnoreCase));
// create function for manual tool changes
QTCDelegate ExecuteManualToolChange = (string title, ToolChangeAction action, int toolNumber, string toolDesc) => {
    var result = DialogResult.None;

    var distanceX = Math.Abs(exec.GetXmachpos() - toolManualPosition.X);
    var distanceY = Math.Abs(exec.GetYmachpos() - toolManualPosition.Y);
    // check if not at manual tool position
    if(distanceX > 0.0001D || distanceY > 0.0001D){
        result = Prompt(title, "Move to position for manual " + action.ToString().ToLower() + " of T" + toolNumber + "?\n" + toolDesc, "YesNoCancel", true);
        if(result == DialogResult.Yes){
            if(!ExecuteGCode("G00 G53 X" + toolManualPosition.X + " Y" + toolManualPosition.Y)){
                exec.AddStatusmessage("M6: tool change interrupted");
                return false;
            }
        }else if(result != DialogResult.No){
            exec.AddStatusmessage("M6: Manual tool " + action.ToString().ToLower() + " for T" + toolNumber + " was canceled");
            exec.Callbutton(buttonCancel);
            return false;
        }
    }

    if(!toolManualATCPrompts){
        result = Prompt("M6: Manual Tool Change", action + " T" + toolNumber + " and press OK to continue\n" + toolDesc, "OKCancel");
        if(result != DialogResult.OK){
            exec.AddStatusmessage("M6: Manual tool change for T" + toolNumber + " was canceled");
            exec.Callbutton(buttonCancel);
            return false;
        }
    }else{
        result = Prompt("M6: Manual Tool Change", (action == ToolChangeAction.Load ?
            "Press OK to open tool clamp" :
            "Secure T" + toolNumber + " and press OK to release tool") +
            "\n" + (action == ToolChangeAction.Load ? "" : toolDesc), "OKCancel"
        );
        if(result != DialogResult.OK){
            exec.AddStatusmessage("M6: Manual tool change for T" + toolNumber + " was canceled");
            exec.Callbutton(buttonCancel);
            return false;
        }
        ATCOpen(atcOutputToolRelease, atcOutputToolClamp, atcOutputPurge);

        result = Prompt("M6: Manual Tool Change", action + " T" + toolNumber + " and press OK to " + (action == ToolChangeAction.Load ? "clamp tool" : "contuine") + "\n" + toolDesc, "OKCancel");
        ATCClose(atcOutputToolRelease, atcOutputToolClamp, atcOutputPurge);
        if(result != DialogResult.OK){
            exec.AddStatusmessage("M6: Manual tool change for T" + toolNumber + " was canceled");
            exec.Callbutton(buttonCancel);
            return false;
        }
    }

    // move back to safe Z - just in case
    if(!ExecuteGCode("G00 G53 Z" + zSafe)){
        exec.AddStatusmessage("M6: tool change interrupted");
        return false;
    }
    return true;
};

if(toolCurrentNumber > 0){
    if(!toolCurrentStorable){
        if(!ExecuteManualToolChange("M6: Tool Not Storable", ToolChangeAction.Unload, toolCurrentNumber, toolCurrentDesc)){
            return;
        }

        if(toolCurrentSlot > 0){
            toolCurrentSlot = 0;
            exec.Writekey(profileToolTableSlotSection, "Slot" + toolCurrentNumber, toolCurrentSlot.ToString());
        }
    }else{
        // if auto-assign enabled and current tool slot is not assigned (zero)
        if(profileAutoAssignToolSlot && toolCurrentSlot < 1){
            // get current used slots
            var usedSlots = new System.Collections.Generic.List<int>();
            for(var i=1; i <= 96; i++){
                 var slot = int.Parse(exec.Readkey(profileToolTableSlotSection, "Slot" + i, "0"));
                 if(slot > 0){
                    usedSlots.Add(slot);
                 }
            }
            
            // find an empty slot #
            var emptySlot = 0;
            for(var i=1; i<=toolSlots.Length; i++){
                if(!usedSlots.Contains(i)){
                    emptySlot = i;
                    break;
                }
            }

            if(emptySlot > 0){
                exec.AddStatusmessage("Assigning T" + toolCurrentNumber + " to empty slot #" + emptySlot);
                // save slot to current tool
                toolCurrentSlot = emptySlot;
                exec.Writekey(profileToolTableSlotSection, "Slot" + toolCurrentNumber, toolCurrentSlot.ToString());
            }
        }

        if(toolCurrentSlot < 1){
            // release current tool manually
            if(!ExecuteManualToolChange("M6: Tool Slot Unavailable", ToolChangeAction.Unload, toolCurrentNumber, toolCurrentDesc)){
                return;
            }
        }else{
            if(!ExecuteGCode(
                // move to current tool slot
                "G00 G53 X" + toolSlots[toolCurrentSlot].X + " Y" + toolSlots[toolCurrentSlot].Y,
                // move Z axis above tool release position
                "G00 G53 Z" + Math.Max(zToolRelease + zRetract, zToolRelease),
                // move Z axis to tool release position
                "G01 G53 F" + zRetractFeed + " Z" + zToolRelease
            )){
                exec.AddStatusmessage("M6: tool change interrupted");
                return;
            }

            // eject tool (3 attempts)
            var counter = 0;
            while(counter < 3 && (counter < 1 || !AssertClampPosition(atcLEDToolClamp, false, atcLEDToolRelease, true))){
                counter++;
                if(counter > 1){
                    ATCClose(atcOutputToolRelease, atcOutputToolClamp, atcOutputPurge);
                }

                ATCOpen(atcOutputToolRelease, atcOutputToolClamp, atcOutputPurge);
            }

            // if tool not clamped and tool release
            if(!AssertClampPosition(atcLEDToolClamp, false, atcLEDToolRelease, true)){
                ATCClose(atcOutputToolRelease, atcOutputToolClamp, atcOutputPurge);

                exec.Callbutton(buttonInterrupt);
                Prompt("M6: Tool Change Failed", "Failed to release tool (ERR1)", "OK", true);
                return;
            }

            // move Z axis up
            if(!ExecuteGCode("G01 G53 F" + zRetractFeed + " Z" + Math.Min(zToolRelease + zRetract, zSafe))){
                exec.AddStatusmessage("M6: tool change interrupted");
                return;
            }

            ATCClose(atcOutputToolRelease, atcOutputToolClamp, atcOutputPurge);

            // check if something is clamped in spindle
            if(!AssertClampPosition(atcLEDToolClamp, false, atcLEDToolRelease, false)){
                exec.Callbutton(buttonInterrupt);
                Prompt("M6: Tool Change Failed", "Failed to release tool (ERR2)", "OK", true);
                return;
            }

            // move back to safe Z
            if(!ExecuteGCode("G00 G53 Z" + zSafe)){
                exec.AddStatusmessage("M6: tool change interrupted");
                return;
            }
        }
    }
}

// nothing should be in spindle at this point
if(!AssertClampPosition(atcLEDToolClamp, false, atcLEDToolRelease, false)){
    exec.Callbutton(buttonInterrupt);
    Prompt("M6: Tool Change Failed", "Spindle not empty", "OK", true);
    return;
}

if(!exec.Ismacrostopped()) {
    exec.Setcurrenttool(0);
}else{
    exec.AddStatusmessage("M6: tool change interrupted");
    return;
}

// if new tool is not in a slot
if(toolNewNumber > 0 && toolNewSlot < 1){
    ATCClose(atcOutputToolRelease, atcOutputToolClamp, atcOutputPurge);

    if(!ExecuteManualToolChange("M6: Tool Missing", ToolChangeAction.Load, toolNewNumber, toolNewDesc)){
        return;
    }
}else if (toolNewNumber > 0 ){
    if(!ExecuteGCode(
        // move to current tool slot
        "G00 G53 X" + toolSlots[toolNewSlot].X + " Y" + toolSlots[toolNewSlot].Y,
        // move Z axis above tool clamp position
        "G00 G53 Z" + Math.Max(zToolClamp + zRetract, zToolClamp)
    )){
        exec.AddStatusmessage("M6: tool change interrupted");
        return;
    }

    // open clamp
    ATCOpen(atcOutputToolRelease, atcOutputToolClamp, atcOutputPurge);

    // check that clamp opened
    if(!AssertClampPosition(atcLEDToolClamp, false, atcLEDToolRelease, true)){
        ATCClose(atcOutputToolRelease, atcOutputToolClamp, atcOutputPurge);
        exec.Callbutton(buttonInterrupt);
        Prompt("M6: Tool Change Failed", "Failed to open clamp", "OK", true);
        return;
    }

    // move Z axis down to tool clamp position
    if(!ExecuteGCode("G01 G53 F" + zRetractFeed + " Z" + zToolClamp)){
        exec.AddStatusmessage("M6: tool change interrupted");
        // Movement was interrupted, so might not be safe to close automatically
        Prompt("M6: Tool Change Interrupted", "Manual closure of ATC is required", "OK", true);
        return;
    }

    // close air and clamp
    ATCClose(atcOutputToolRelease, atcOutputToolClamp, atcOutputPurge);

    // move Z axis back above tool clamp position
    if(!ExecuteGCode("G00 G53 Z" + Math.Max(zToolClamp + zRetract, zToolClamp))){
        exec.AddStatusmessage("M6: tool change interrupted");
        return;
    }

    // check tool is clamped
    if(!AssertClampPosition(atcLEDToolClamp, true, atcLEDToolRelease, false)){
        exec.Callbutton(buttonInterrupt);
        Prompt("M6: Tool Change Failed", "Failed to clamp tool", "OK", true);
        return;
    }

    // move back to safe Z
    if(!ExecuteGCode("G00 G53 Z" + zSafe)){
        exec.AddStatusmessage("M6: tool change interrupted");
        return;
    }
}

// check if nothing is clamped in spindle
if(toolNewNumber > 0 && !AssertClampPosition(atcLEDToolClamp, true, atcLEDToolRelease, false)){
    exec.Callbutton(buttonInterrupt);
    exec.Setcurrenttool(0);
    Prompt("M6: Tool Change Failed", "Tool not in spindle", "OK", true);
    return;
}

if(!exec.Ismacrostopped()) {
    exec.Setcurrenttool(toolNewNumber);

    if(!ExecuteGCode(
        // move to safe z
        "G00 G53 Z" + zSafe,
        // move back to original XY position
        "G00 G53 X" + originalPosition.X + " Y" + originalPosition.Y
    )){
        ATCClose(atcOutputToolRelease, atcOutputToolClamp, atcOutputPurge);
        exec.AddStatusmessage("M6: tool change interrupted");
        return;
    }

    // restore modal
    if(!ExecuteGCode(originalModal)){
        exec.AddStatusmessage("M6: tool change interrupted");
        return;
    }
}else{
    ATCClose(atcOutputToolRelease, atcOutputToolClamp, atcOutputPurge);
    exec.AddStatusmessage("M6: tool change interrupted");
    return;
}

#Events
// ### GLOBAL UTILS ###

private bool ExecuteGCode(params string[] code) {
    exec.Codelist(new List<string>(code));
    while(exec.IsMoving()){}

    return !exec.Ismacrostopped() && !exec.GetLED(25); // !STOP && !RESET
}

private DialogResult Prompt(string title, string messsage, string button, bool warning = false) {
    var result = exec.Informplugin("Messages.dll", string.Format("{0}{1}:{2}|{3}", warning ? "!" : "", button, title, messsage));
    return result is DialogResult ? (DialogResult)result : DialogResult.None;
}

private void ATCOpen(PortPin outputRelease, PortPin? outputClamp, PortPin outputAir) {
    if(outputClamp != null){
        exec.Clroutpin(outputClamp.Value.Port, outputClamp.Value.Pin);
        exec.Wait(250);
    }

    exec.Setoutpin(outputRelease.Port, outputRelease.Pin);
    exec.Wait(250);

    exec.Setoutpin(outputAir.Port, outputAir.Pin);
    exec.Wait(250);
}

private void ATCClose(PortPin outputRelease, PortPin? outputClamp, PortPin outputAir) {
    exec.Clroutpin(outputAir.Port, outputAir.Pin);
    exec.Wait(250);

    exec.Clroutpin(outputRelease.Port, outputRelease.Pin);
    exec.Wait(250);

    if(outputClamp != null){
        exec.Setoutpin(outputClamp.Value.Port, outputClamp.Value.Pin);
        exec.Wait(250);
    }
}

private bool AssertClampPosition(int clampLed, bool clampExpected, int releaseLed, bool releaseExpected) {
    var retry = 4;
    var debounce = 2;
    var result = false;

    do{
        // dwell after first
        if(debounce < 2 || retry < 4){ exec.Wait(250); }

        var clampState = exec.GetLED(clampLed);
        var releaseState = exec.GetLED(releaseLed);

        result = clampState == clampExpected && releaseState == releaseExpected;
        debounce = result ? debounce - 1 : 2;
        retry = result ? retry : retry - 1;
    }while(retry > 0 && debounce > 0 && !result);

    return result;
}

private enum ToolChangeAction {
    Load,
    Unload
}

delegate bool QTCDelegate (string title, ToolChangeAction action, int toolNumber, string toolDesc);

private struct Position {
    public Position(double x, double y) {
        this.X = x;
        this.Y = y;
    }

    public double X;
    public double Y;
}

private struct PortPin {
    public PortPin(int port, int pin) {
        this.Port = port;
        this.Pin = pin;
    }

    public int Port;
    public int Pin;
}