/**
 * Macro: M31 Tool Offset Measure /w breakage detection
 * UCCNC v1.2115 or higher required with Messages, Probe plugins enabled and fixed probe location set.
 * M31 [Hn] [En.n]
 * - H: Tool offset number (optional, defaults to active G43Hn or current tool)
 * - E: Tool breakage tolerance value (optional, defaults to no tolerance)
 */

// ### M31 CONFIG ###

// INPUT to detect if a tool is clamped
var atcLEDToolClamp = 96; // InputPT3PN11
// INPUT to detect tool release
var atcLEDToolRelease = 97; // InputPT3PN12

// Interrupt from failure: 130=Cycle Stop or 512=RESET
var buttonInterrupt = 130;
// Cancel from user: 130=Cycle Stop or 512=RESET
var buttonCancel = 130;

// safe Z position for travel
double zSafe = 0.0D;
// Max Z machine position to probe to
var probeZ = -5.0D;

// get retract setting from probe plugin
var probeRetract = double.Parse(AS3.Getfield(2707)); // Retract
// get fast feed rate setting from probe plugin
var probeFastFeed = double.Parse(AS3.Getfield(2709)); // FastFeed
// get fine feed rate setting from probe plugin
var probeFineFeed = double.Parse(AS3.Getfield(2710)); // FineFeed

// get the fixed probe location setting from probe plugin
var probePosition = new Position(double.Parse(AS3.Getfield(2726)), double.Parse(AS3.Getfield(2727))); // FixedProbePosX, FixedProbePosY
var probePositionZ = double.Parse(AS3.Getfield(2728)); // FixedProbePosZ

// starting numbers to calculate z offset field number
var fieldStartIdxToolZ_1 = 195; // 196-215 - T1-20
var fieldStartIdxToolZ_2 = 900; // 921-996 - T21-96

// ### M31 MACRO ###

// get the current tool
var toolCurrentNumber = exec.Getcurrenttool();

// get the current G43 offset from active modal
var modalG43 = System.Text.RegularExpressions.Regex.Match(AS3.Getfield(877), "G43H(\\d+)");
int? offsetCurrentNumber = modalG43.Success ? (int?)int.Parse(modalG43.Groups[1].Value) : null;

// get the offset tool number
int offsetToolNumber = (Allvars != null ? (Allvars.Hvar != null ? (int?)Allvars.Hvar : null) : null) ?? offsetCurrentNumber ?? toolCurrentNumber;
var fieldStartIdxToolZ = offsetToolNumber < 21 ? fieldStartIdxToolZ_1 : fieldStartIdxToolZ_2;

// get values needed for breakage detection
var toolBreakageTolerance = (Allvars != null ? Allvars.Evar : null);
var offsetCurrentZ = offsetToolNumber > 0 ? double.Parse(AS3.Getfield(fieldStartIdxToolZ+offsetToolNumber)) : 0.0D;

// exec.AddStatusmessage("M31: H" + offsetToolNumber.ToString() + (toolBreakageTolerance != null ? " E" + toolBreakageTolerance : "") + " (Current Offset: " + offsetCurrentZ + ")");

if(toolBreakageTolerance != null && toolBreakageTolerance < 0.0D){
    exec.Callbutton(buttonInterrupt);
    exec.AddStatusmessage("M31: E" + toolBreakageTolerance + " tool tolerance must be absolute value");
    return;
}

if(offsetToolNumber < 1 || offsetToolNumber > 96){
    exec.Callbutton(buttonInterrupt);
    exec.AddStatusmessage("M31: H" + offsetToolNumber + " tool offset number out of range");
    return;
}

 // If machine was not homed then it is unsafe to move in machine coordinates, stop here...
if(!exec.GetLED(56)||!exec.GetLED(57)||!exec.GetLED(58))
{
    exec.Callbutton(buttonInterrupt);
    Prompt("M31: Tool Offset Probe", "Machine is not homed", "OK", true);
    return;
}

// check that there is a tool in spindle
if(toolCurrentNumber < 1 || !AssertClampPosition(atcLEDToolClamp, true, atcLEDToolRelease, false)){
    exec.Callbutton(buttonInterrupt);
    Prompt("M31: Tool Offset Probe", "Tool not in spindle", "OK", true);
    return;
}

var toolMasterNumber = 0;
// find master tool number
for(var i=1; i <= 96; i++){
     var toolTypeFlags = exec.Readkey("Tooltablevalues", "Type" + i, "").Split(new char[]{' ', ',', ';'});
     if(Array.Exists(toolTypeFlags, f => string.Equals(f, "Master", StringComparison.InvariantCultureIgnoreCase))){
      toolMasterNumber = i;
      break;
     }
}
if(toolMasterNumber < 1){
    exec.Callbutton(buttonInterrupt);
    Prompt("M31: Tool Offset Probe", "No master tool reference found", "OK", true);
    return;
}

// get master tool description
var toolMasterDesc = exec.Readkey("Tooltablevalues", "Description" + toolMasterNumber, "");

// get the Z machine position of the master tool, fail if one is not set
var toolMasterProbeZ = double.Parse(exec.Readkey("M31Macro", "MasterToolProbeZ", "NaN"));
if(double.NaN.Equals(toolMasterProbeZ)){
    if(offsetToolNumber != toolMasterNumber){
        exec.Callbutton(buttonInterrupt);
        Prompt("M31: Tool Offset Probe", "T" + toolMasterNumber + " master tool reference not probed", "OK", true);
        return;
    }
    toolMasterProbeZ = 0.0D;
}

// if the tool offset is master, warn of updating master
if(offsetToolNumber == toolMasterNumber){
    var result = Prompt("M31: Tool Offset Probe", "Probing T" + toolMasterNumber + " master tool reference may skew current known tool offsets\nContinue probing master tool reference?\n" + toolMasterDesc, "OKCancel", true);

    if(result != DialogResult.OK){
        exec.AddStatusmessage("M31: Tool offset probe was canceled");
        exec.Callbutton(buttonCancel);
        return;
    }
}

// store original position to move back to
var originalPosition = new Position(exec.GetXmachpos(), exec.GetYmachpos());
var originalModal = AS3.Getfield(877).Split('|');

if(!ExecuteGCode(
    // stop coolant and spindle
    "M9", "M5",
    // move to safe z
    "G90 G00 G53 Z" + zSafe,
    // move to fixed probe
    "G00 G53 X" + probePosition.X + " Y" + probePosition.Y,
    "G00 G53 Z" + probePositionZ,
    // cancel out tool offset and scale
    "G49 G50"
)){
    exec.AddStatusmessage("M31: tool offset probe interrupted");
    return;
}

// two stage probe, fast then fine feed rate
for(var i=0; i<2; i++){
    // first probe use fast feed, second use fine feed
    var feedRate = i < 1 ? probeFastFeed : probeFineFeed;
    // first probe use fixed probe distance, second use retract distance
    var z = i < 1 ? probeZ : -probeRetract;

    if(!ExecuteGCode(
        // start probing
        "G91 F" + feedRate + " G31 Z" + z
    )){
        exec.AddStatusmessage("M31: tool offset probe interrupted");
        return;
    }

    // check probe status outcome
    var probeStatus = exec.Getvar(5060);
    if(probeStatus == 1){
        exec.AddStatusmessage("M31: Failed to probe H" + offsetToolNumber + " tool offset with-in travel");
        exec.Callbutton(buttonInterrupt);
        return;
    }else if(probeStatus != 0){
        exec.AddStatusmessage("M31: Failed to probe H" + offsetToolNumber + " tool offset (ERR" + probeStatus + ")");
        exec.Callbutton(buttonInterrupt);
        return;
    }

    if(!ExecuteGCode(
        // retract
        "G91 G00 Z" + probeRetract
    )){
        exec.AddStatusmessage("M31: tool offset probe interrupted");
        return;
    }
}

if(!ExecuteGCode(
        // change to absolute mode
        "G90",
        // Go to safe Z
        "G00 G53 Z" + zSafe
)){
    exec.AddStatusmessage("M31: tool offset probe interrupted");
    return;
}

if(!exec.Ismacrostopped()){
    // get probe Z result
    var offsetProbeZ = exec.Getvar(5063);
    // add current work offset to get probe in machine pos
    offsetProbeZ += exec.GetZmachpos() - exec.GetZpos();

    // calculate offset Z from master tool (zero out if is master tool)
    var offsetToolZ = offsetToolNumber != toolMasterNumber ? offsetProbeZ - toolMasterProbeZ : 0.0D;

    if(toolBreakageTolerance != null){
        // check for tool is with-in tollerance
        var offsetDifference = Math.Abs(offsetCurrentZ - offsetToolZ);
        if(offsetDifference > toolBreakageTolerance){
            exec.AddStatusmessage("M31: Tool offset H" + offsetToolNumber + " measured Z" + offsetToolZ);
            exec.AddStatusmessage("M31: Tool offset H" + offsetToolNumber + " measurement is out of tolerance: " + offsetDifference + ">" + toolBreakageTolerance);
            exec.Callbutton(buttonInterrupt);
            Prompt("M31: Tool Offset Probe", "Tool breakage detected for T" + toolCurrentNumber + " H" + offsetToolNumber, "OK", true);
            return;
        }
    }

    // update tool master
    if(offsetToolNumber == toolMasterNumber){
        exec.AddStatusmessage("M31: Setting global master tool reference to Z" + offsetProbeZ);
        exec.Writekey("M31Macro", "MasterToolProbeZ", offsetProbeZ.ToString());
    }

    // update tool offset in tool table field
    exec.AddStatusmessage("M31: Setting H" + offsetToolNumber + " tool offset to Z" + offsetToolZ);
    AS3.Setfieldtext(offsetToolZ.ToString(), fieldStartIdxToolZ+offsetToolNumber);
    AS3.Validatefield(fieldStartIdxToolZ+offsetToolNumber);

    // save tool offset in profile
    exec.Writekey("Tooltablevalues", "TooloffsetZ"+offsetToolNumber, offsetToolZ.ToString());

    if(!ExecuteGCode(
            // Go to safe Z
            "G00 G53 Z" + zSafe
    )){
        exec.AddStatusmessage("M31: tool offset probe interrupted");
        return;
    }

    if(!ExecuteGCode(
        // restore modal
        originalModal
    )){
        exec.AddStatusmessage("M31: tool offset probe interrupted");
        return;
    }
}else{
    exec.AddStatusmessage("M31: tool offset probe was interrupted");
    exec.Callbutton(buttonInterrupt);
    return;
}

#Events
// ### GLOBAL UTILS ###

private bool ExecuteGCode(params string[] code) {
    exec.Codelist(new List<string>(code));
    while(exec.IsMoving()){}

    return !exec.Ismacrostopped() && !exec.GetLED(25); // !STOP && !RESET
}

private DialogResult Prompt(string title, string messsage, string button, bool warning = false) {
    var result = exec.Informplugin("Messages.dll", string.Format("{0}{1}:{2}|{3}", warning ? "!" : "", button, title, messsage));
    return result is DialogResult ? (DialogResult)result : DialogResult.None;
}

private bool AssertClampPosition(int clampLed, bool clampExpected, int releaseLed, bool? releaseExpected = null) {
    var retry = 4;
    var debounce = 2;
    var result = false;

    do{
        // dwell after first
        if(debounce < 2 || retry < 4){ exec.Wait(250); }

        var clampState = exec.GetLED(clampLed);
        var releaseState = exec.GetLED(releaseLed);

        result = clampState == clampExpected && (releaseExpected == null || releaseState == releaseExpected.Value);
        debounce = result ? debounce - 1 : 2;
        retry = result ? retry : retry - 1;
    }while(retry > 0 && debounce > 0 && !result);

    return result;
}

private struct Position {
    public Position(double x, double y) {
        this.X = x;
        this.Y = y;
    }

    public double X;
    public double Y;
}

private struct PortPin {
    public PortPin(int port, int pin) {
        this.Port = port;
        this.Pin = pin;
    }

    public int Port;
    public int Pin;
}